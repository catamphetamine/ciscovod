From 234ed6dcf3187dbd6382f85326e773ae3b2148bf Mon Sep 17 00:00:00 2001
From: mscdex <mscdex@mscdex.net>
Date: Fri, 24 May 2013 07:43:21 -0400
Subject: [PATCH] connection: always immediately send key exchange init upon
 receipt of greeting

---
 lib/Connection.js | 263 +++++++++++++++++++++++++++++++-----------------------
 1 file changed, 149 insertions(+), 114 deletions(-)

diff --git a/lib/Connection.js b/lib/Connection.js
index c95b807..3adb982 100644
--- a/lib/Connection.js
+++ b/lib/Connection.js
@@ -80,15 +80,14 @@ function Connection(opts) {
     self._debug&&self._debug('DEBUG: Connection: Server ident: '
                              + inspect(header.ident_raw));
     self._server_ident_raw = header.ident_raw;
+    sendKEXInit();
   });
 
   //this._parser.on('DEBUG', function(msg, lang) {
   //  self._debug&&self._debug('Server debug: ' +  msg);
   //});
 
-  this._parser.on('KEXINIT', function(init) {
-    if (this._state === 'authenticated')
-      this._state = 'reexchg';
+  function sendKEXInit(cb) {
     crypto.randomBytes(16, function(err, my_cookie) {
       /*
         byte         SSH_MSG_KEXINIT
@@ -167,131 +166,167 @@ function Connection(opts) {
 
       self._debug&&self._debug('DEBUG: Connection: Sent KEXINIT');
       self._kexinit = bufKexInit;
-      self._send(bufKexInit, function() {
-        // check for agreeable server->client cipher
-        for (i=0,len=ALGORITHMS.CIPHER.length;
-             i<len && init.algorithms.sc.encrypt.indexOf(ALGORITHMS.CIPHER[i])
-                      === -1;
-             ++i);
-        if (i === len) {
-          // no suitable match found!
-          self._parser.reset();
-          return self._disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
-        }
+      self._send(bufKexInit);
+      self.emit('_sentKEXInit');
+    });
+  }
 
-        self._parser._decryptType = ALGORITHMS.CIPHER[i];
-
-        // check for agreeable client->server cipher
-        for (i=0,len=ALGORITHMS.CIPHER.length;
-             i<len && init.algorithms.cs.encrypt.indexOf(ALGORITHMS.CIPHER[i])
-                      === -1;
-             ++i);
-        if (i === len) {
-          // no suitable match found!
-          self._parser.reset();
-          return self._disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
-        }
+  function checkSKEXInit(init, cb) {
+    self._debug&&self._debug('DEBUG: Connection: Comparing KEXInits...');
+    // check for agreeable server->client cipher
+    for (i=0,len=ALGORITHMS.CIPHER.length;
+         i<len && init.algorithms.sc.encrypt.indexOf(ALGORITHMS.CIPHER[i])
+                  === -1;
+         ++i);
+    if (i === len) {
+      // no suitable match found!
+      self._parser.reset();
+      self._disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
+      return;
+    }
 
-        self._encryptType = ALGORITHMS.CIPHER[i];
+    self._parser._decryptType = ALGORITHMS.CIPHER[i];
 
-        // check for agreeable key exchange algorithm
-        for (i=0,len=ALGORITHMS.KEX.length;
-             i<len && init.algorithms.kex.indexOf(ALGORITHMS.KEX[i]) === -1;
-             ++i);
-        if (i === len) {
-          // no suitable match found!
-          self._parser.reset();
-          return self._disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
-        }
+    // check for agreeable client->server cipher
+    for (i=0,len=ALGORITHMS.CIPHER.length;
+         i<len && init.algorithms.cs.encrypt.indexOf(ALGORITHMS.CIPHER[i])
+                  === -1;
+         ++i);
+    if (i === len) {
+      // no suitable match found!
+      self._parser.reset();
+      self._disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
+      return;
+    }
 
-        var kex_algorithm = ALGORITHMS.KEX[i],
-            bufDHInit;
-
-        // check for agreeable client->server hmac algorithm
-        for (i=0,len=ALGORITHMS.HMAC.length;
-             i<len && init.algorithms.cs.mac.indexOf(ALGORITHMS.HMAC[i]) === -1;
-             ++i);
-        if (i === len) {
-          // no suitable match found!
-          self._parser.reset();
-          return self._disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
-        }
+    self._encryptType = ALGORITHMS.CIPHER[i];
 
-        self._hmac = ALGORITHMS.HMAC[i];
+    // check for agreeable key exchange algorithm
+    for (i=0,len=ALGORITHMS.KEX.length;
+         i<len && init.algorithms.kex.indexOf(ALGORITHMS.KEX[i]) === -1;
+         ++i);
+    if (i === len) {
+      // no suitable match found!
+      self._parser.reset();
+      self._disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
+      return;
+    }
 
-        // check for agreeable server->client hmac algorithm
-        for (i=0,len=ALGORITHMS.HMAC.length;
-             i<len && init.algorithms.sc.mac.indexOf(ALGORITHMS.HMAC[i]) === -1;
-             ++i);
-        if (i === len) {
-          // no suitable match found!
-          self._parser.reset();
-          return self._disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
-        }
+    var kex_algorithm = ALGORITHMS.KEX[i];
 
-        self._parser._hmac = ALGORITHMS.HMAC[i];
-
-        // check for agreeable client->server compression algorithm
-        for (i=0,len=ALGORITHMS.COMPRESS.length;
-             i<len && init.algorithms.cs.compress
-                                        .indexOf(ALGORITHMS.COMPRESS[i]) === -1;
-             ++i);
-        if (i === len) {
-          // no suitable match found!
-          self._parser.reset();
-          return self._disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
-        }
+    // check for agreeable client->server hmac algorithm
+    for (i=0,len=ALGORITHMS.HMAC.length;
+         i<len && init.algorithms.cs.mac.indexOf(ALGORITHMS.HMAC[i]) === -1;
+         ++i);
+    if (i === len) {
+      // no suitable match found!
+      self._parser.reset();
+      self._disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
+      return;
+    }
 
-        self._compressType = ALGORITHMS.COMPRESS[i];
-
-        // check for agreeable server->client compression algorithm
-        for (i=0,len=ALGORITHMS.COMPRESS.length;
-             i<len && init.algorithms.sc.compress
-                                        .indexOf(ALGORITHMS.COMPRESS[i]) === -1;
-             ++i);
-        if (i === len) {
-          // no suitable match found!
-          self._parser.reset();
-          return self._disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
-        }
+    self._hmac = ALGORITHMS.HMAC[i];
 
-        self._parser._compressType = ALGORITHMS.COMPRESS[i];
-
-        // check for agreeable server host key format
-        for (i=0,len=ALGORITHMS.SERVER_HOST_KEY.length;
-             i<len && init.algorithms.srvHostKey
-                          .indexOf(ALGORITHMS.SERVER_HOST_KEY[i]) === -1;
-             ++i);
-        if (i === len) {
-          // no suitable match found!
-          self._parser.reset();
-          return self._disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
-        }
+    // check for agreeable server->client hmac algorithm
+    for (i=0,len=ALGORITHMS.HMAC.length;
+         i<len && init.algorithms.sc.mac.indexOf(ALGORITHMS.HMAC[i]) === -1;
+         ++i);
+    if (i === len) {
+      // no suitable match found!
+      self._parser.reset();
+      self._disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
+      return;
+    }
 
-        self._hostkey_format = ALGORITHMS.SERVER_HOST_KEY[i];
+    self._parser._hmac = ALGORITHMS.HMAC[i];
 
-        if (kex_algorithm === 'diffie-hellman-group1-sha1')
-          self._kex = crypto.getDiffieHellman('modp2');
-        else if (kex_algorithm === 'diffie-hellman-group14-sha1')
-          self._kex = crypto.getDiffieHellman('modp14');
+    // check for agreeable client->server compression algorithm
+    for (i=0,len=ALGORITHMS.COMPRESS.length;
+         i<len && init.algorithms.cs.compress
+                                    .indexOf(ALGORITHMS.COMPRESS[i]) === -1;
+         ++i);
+    if (i === len) {
+      // no suitable match found!
+      self._parser.reset();
+      self._disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
+      return;
+    }
 
-        self._pubkey = new Buffer(self._kex.generateKeys('binary'), 'binary');
-        if (self._pubkey[0] & 0x80) {
-          var key = new Buffer(self._pubkey.length + 1);
-          key[0] = 0;
-          self._pubkey.copy(key, 1);
-          self._pubkey = key;
-        }
+    self._compressType = ALGORITHMS.COMPRESS[i];
 
-        bufDHInit = new Buffer(1 + 4 + self._pubkey.length);
-        bufDHInit[0] = MESSAGE.KEXDH_INIT;
-        bufDHInit.writeUInt32BE(self._pubkey.length, 1, true);
-        self._pubkey.copy(bufDHInit, 5);
+    // check for agreeable server->client compression algorithm
+    for (i=0,len=ALGORITHMS.COMPRESS.length;
+         i<len && init.algorithms.sc.compress
+                                    .indexOf(ALGORITHMS.COMPRESS[i]) === -1;
+         ++i);
+    if (i === len) {
+      // no suitable match found!
+      self._parser.reset();
+      self._disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
+      return;
+    }
 
-        self._debug&&self._debug('DEBUG: Connection: Sent KEXDH_INIT');
-        self._send(bufDHInit);
-      });
-    });
+    self._parser._compressType = ALGORITHMS.COMPRESS[i];
+
+    // check for agreeable server host key format
+    for (i=0,len=ALGORITHMS.SERVER_HOST_KEY.length;
+         i<len && init.algorithms.srvHostKey
+                      .indexOf(ALGORITHMS.SERVER_HOST_KEY[i]) === -1;
+         ++i);
+    if (i === len) {
+      // no suitable match found!
+      self._parser.reset();
+      self._disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
+      return;
+    }
+
+    self._hostkey_format = ALGORITHMS.SERVER_HOST_KEY[i];
+
+    if (kex_algorithm === 'diffie-hellman-group1-sha1')
+      self._kex = crypto.getDiffieHellman('modp2');
+    else if (kex_algorithm === 'diffie-hellman-group14-sha1')
+      self._kex = crypto.getDiffieHellman('modp14');
+
+    self._pubkey = new Buffer(self._kex.generateKeys('binary'), 'binary');
+    if (self._pubkey[0] & 0x80) {
+      var key = new Buffer(self._pubkey.length + 1);
+      key[0] = 0;
+      self._pubkey.copy(key, 1);
+      self._pubkey = key;
+    }
+
+    return true;
+  }
+
+  function sendKEXDHInit() {
+    var bufDHInit = new Buffer(1 + 4 + self._pubkey.length);
+    bufDHInit[0] = MESSAGE.KEXDH_INIT;
+    bufDHInit.writeUInt32BE(self._pubkey.length, 1, true);
+    self._pubkey.copy(bufDHInit, 5);
+
+    self._debug&&self._debug('DEBUG: Connection: Sent KEXDH_INIT');
+    self._send(bufDHInit);
+  }
+
+  this._parser.on('KEXINIT', function(init) {
+    var waitForSend = (self._kexinit === undefined);
+
+    if (self._state === 'authenticated') {
+      self._state = 'reexchg';
+      self._kexinit = undefined;
+      sendKEXInit();
+      waitForSend = true;
+    }
+
+    if (waitForSend)
+      self.once('_sentKEXInit', doCheck);
+    else
+      doCheck();
+
+    function doCheck() {
+      if (checkSKEXInit(init) === true)
+        sendKEXDHInit();
+    }
   });
 
   this._parser.on('KEXDH_REPLY', function(info) {
-- 
1.8.0.msysgit.0
